@{
    Layout = "~/Views/Shared/_Layout.cshtml";
}

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
    tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]}
    });
</script>

<script src="/Scripts/MathJax/MathJax.js"></script>


<div class="post-title post-title-tsucs">
    <div class="container">
        <div class="row">
            <div class="col-md-8 col-md-offset-2">

                <h1>POV-Ray rendering of Three-Scroll Unified Chaotic System</h1>
            </div>
        </div>
    </div>
</div>

<div class="container">
    <div class="row">
        <div class="col-md-10 col-md-offset-1">
            <p>
                The Three-Scroll Unified Chaotic System (TSUCS) was introduced by Lin Pan, Wuneng Zhou, Jian’an Fang and Dequan Li in <a href="http://www.internonlinearscience.org/upload/papers/20110618025420887.pdf">a paper submitted to the International Journal of Nonlinear Science</a> in 2010. The TSUCS contains both a Lorenz-style attractor and also a Lu Chen-style attractor at its extremes.
            </p>
       
            <p>
                \begin{align}
                \frac{dx}{dt} & = \textrm{a} (y - x) + \textrm{d} x y \\
                \frac{dy}{dt} & = \textrm{c}x - xy + \textrm{f}y \\
                \frac{dz}{dt} & = \textrm{b}z + yx - \textrm{e}x^2 \\
                \end{align}
            </p>

            where I use the parameters
            <p>
                \begin{align}
                \textrm{a} & = 40 \\
                \textrm{b} & = 1.833 \\
                \textrm{c} & = 55 \\
                \textrm{d} & = 0.16 \\
                \textrm{e} & = 0.65 \\
                \textrm{f} & = 20                
                \end{align}

            </p>
            
            <p>
                The POV-Ray macro for rendering this attractor is:
            </p>
            <pre>
                               //Draws a Three-Scroll Unified Chaotic System 
#macro TSUCS(a, b, c, d, e, f, dT, Iter, x0, y0, z0, R) 
    #local Count=0;
	#while (Count&lt;Iter)        
		#local x1=x0+dT*(a*(y0-x0) + (d*x0*z0));
		#local y1=y0+dT*((c * x0) - (x0*z0) + (f*y0));
        #local z1=z0+dT*((b * z0) + (x0 * y0) - (e * x0 * x0));		
        #if(Count &lt; (Iter - 1500))	
    		sphere {
    		    &lt;x1,y1,z1&rt;, R
                pigment { 
                    rgb &lt;0.9-(Count/Iter)*0.7,0.6,0.2+(Count/Iter)*0.7&rt;
                }
                finish { 
                    diffuse 0.7
                    ambient 0.3 
                    specular 0.5
                    reflection { 
                        0.9  metallic 
                    } 
                }
            }
        #else
            sphere {
                &lt;x1,y1,z1&rt;, R
                pigment { 
                    rgb &lt;(Count/Iter),(Count/Iter)*0.25,(Count/Iter)*0.25&rt;
                }
                finish{
                    diffuse 0.7
                    ambient 0.9
                    specular 0.3
                    reflection { 
                        0.8  metallic 
                    } 
                }
            }
        #end                                             
		#local Count=Count+1;
		#local x0=x1;
		#local y0=y1;
		#local z0=z1;
	#end
#end
</pre>

        </div>

    </div>

</div>